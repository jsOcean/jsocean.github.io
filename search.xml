<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JavaScript 几种简单的设计模式</title>
      <link href="/2019/04/15/JavaScript-%E5%87%A0%E7%A7%8D%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/15/JavaScript-%E5%87%A0%E7%A7%8D%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大家都知道JavaScript设计模式在整个前端占有很重要的地位，它让我们站在巨人的肩膀上，保证我们以优雅的方式组织我们的代码，满足我们解决问题所需要的条件。</p><h3 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个模式就是一个可重用的方案，可应用于在软件设计中的常见问题，它有如下优点：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 模式是行之有效的解决方法：他们提供固定的解决方法来解决在软件开发中出现的问题，这些都是久经考验的反应了开发者的经验和见解的使用模式来定义的技术。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 模式可以很容易地重用：一个模式通常反映了一个可以适应自己需要的开箱即用的解决方案。这个特性让它们很健壮。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 模式善于表达：当我们看到一个提供某种解决方案的模式时，一般有一组结构和词汇可以非常优雅地帮助表达相当大的解决方案。</p><h3 id="几种JavaScript的设计模式"><a href="#几种JavaScript的设计模式" class="headerlink" title="几种JavaScript的设计模式"></a>几种JavaScript的设计模式</h3><h4 id="JavaScript-构造器模式"><a href="#JavaScript-构造器模式" class="headerlink" title="JavaScript 构造器模式"></a>JavaScript 构造器模式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在面向对象编程中，构造器是一个当新建对象的内存被分配后，用来初始化该对象的一个特殊函数，在JavaScript中几乎所有的东西都是对象。</p><pre><code class="JavaScript">    /**    * 构造一个车的函数     */    function car(name, color) {        this.name = name;        this.color = color;        this.getName = function () {            return &#39;名称：&#39; + this.name + &#39;\n颜色：&#39; + this.color;        }    }    // 实例一个对象    var cat = new car(&#39;凯迪拉克&#39;, &#39;白色&#39;);    console.log(cat.getName());</code></pre><h4 id="JavaScript-暴露模块模式"><a href="#JavaScript-暴露模块模式" class="headerlink" title="JavaScript 暴露模块模式"></a>JavaScript 暴露模块模式</h4><pre><code class="JavaScript">    var myRevealingModule = function () {        var privateVar = &quot;Ben Cherry&quot;,            publicVar = &quot;Hey there!&quot;;        function privateFunction() {            console.log(&quot;Name:&quot; + privateVar);        }        function publicSetName(strName) {            privateVar = strName;            privateFunction();        }        function publicGetName() {            privateFunction();        }        return {            setName: publicSetName,            getName: publicGetName        };    }();    myRevealingModule.getName(&quot;Paul Kinlan&quot;);</code></pre><h4 id="JavaScript-工厂模式"><a href="#JavaScript-工厂模式" class="headerlink" title="JavaScript 工厂模式"></a>JavaScript 工厂模式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;工厂模式是另外一种关注对象创建概念的创建模式。它的领域中同其它模式的不同之处在于它并没有明确要求我们使用一个构造器。取而代之，一个工厂能提供一个创建对象的公共接口，我们可以在其中指定我们希望被创建的工厂对象的类型。</p><pre><code class="javaScript">function car(opts) {    var obj = new Object();    obj.name = opts.name;    obj.color = opts.color;    obj.getInfo = function () {        return &#39;名称：&#39; + obj.name + &#39;， 颜色：&#39; + obj.color;    }    return obj;}var cat = car({ name: &#39;凯迪拉克&#39;, color: &#39;白色&#39; });console.log(cat.getInfo());</code></pre><h4 id="JavaScript-单例模式"><a href="#JavaScript-单例模式" class="headerlink" title="JavaScript 单例模式"></a>JavaScript 单例模式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单例就是保证一个类只有一个实例，实现方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。</p><pre><code class="JavaScript">var Single = (function () {    var instance;    function init() {        //define private methods and properties        //do something        return {            //define public methods and properties        };    }    return {        // 获取实例        getInstance: function () {            if (!instance) {                instance = init();            }            return instance;        }    }})();var obj1 = Single.getInstance();var obj2 = Single.getInstance();console.log(obj1 === obj2);</code></pre><h4 id="JavaScript-原型模式"><a href="#JavaScript-原型模式" class="headerlink" title="JavaScript 原型模式"></a>JavaScript 原型模式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原型模式，就是创建一个共享的原型，通过拷贝这个原型来创建新的类，用于创建重复的对象，带来性能上的提升。</p><pre><code class="JavaScript">var vehiclePrototype = {    init: function (carModel) {        this.model = carModel;    },    getModel: function () {        console.log(&#39;车辆模具是：&#39; + this.model);    }};function vehicle(model) {    function F() { };    F.prototype = vehiclePrototype;        var f = new F();    f.init(model);    return f;}var car = vehicle(&#39;法拉利&#39;);car.getModel();</code></pre><h4 id="JavaScript-混合模式"><a href="#JavaScript-混合模式" class="headerlink" title="JavaScript 混合模式"></a>JavaScript 混合模式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 混合模式是由构造函数模式和原型模式构成，构造函数模式用于定义实例属性，而原型模式用于定义方法和共享属性。每个实例都会有自己的一份实例属性，但同时又共享着方法，最大限度的节省了内存。另外这种模式还支持传递初始参数。这种模式在ECMAScript中是使用最广泛、认同度最高的一种创建自定义对象的方法。</p><pre><code class="JavaScript">// 为父类型创建构造函数function SuperType(name) {    this.name = name;    this.color = [&#39;pink&#39;, &#39;yellow&#39;];    this.property = true;    this.testFun = function () {        console.log(&#39;http://tools.jb51.net/&#39;);    }}// 为父类型添加方法SuperType.prototype.getSuerperValue = function () {    return this.property;}// 为子类型创建构造函数function SubType(name) {    SuperType.call(this, name);    this.test = [&#39;h1&#39;, &#39;h2&#39;, &#39;h3&#39;, &#39;h4&#39;];    this.subproperty = false;}SubType.prototype = new SuperType();// 在此处给子类型添加方法，一定要在实现继承之后，否则会在将指针指向父类型的实例，则方法为空SubType.prototype.getSubValue = function () {    return this.subproperty;}/* 以下为测试代码示例 */var instance1 = new SubType([&#39;wuyuchang&#39;, &#39;Jack&#39;, &#39;Nick&#39;]);instance1.name.push(&#39;hello&#39;);instance1.test.push(&#39;h5&#39;);instance1.color.push(&#39;blue&#39;);instance1.testFun();            // http://tools.jb51.net/console.log(instance1.name);            // wuyuchang,Jack,Nick,helloconsole.log(instance1.getSuerperValue());      // trueconsole.log(instance1.test);            // h1,h2,h3,h4,h5    console.log(instance1.getSubValue());        // false    console.log(instance1.color);            // pink,yellow,bluevar instance2 = new SubType(&#39;wyc&#39;);instance2.testFun();            // http://tools.jb51.net/console.log(instance2.name);            // wyc    console.log(instance2.getSuerperValue());      // trueconsole.log(instance2.test);            // h1,h2,h3,h4console.log(instance2.getSubValue());        // falseconsole.log(instance2.color);            // pink,yellow</code></pre><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 看了上面的一些示例，应该对JavaScript设计模式有了一些了解，设计模式有很多种类，我这边只是写了简单常用的几种模式，希望对你有所帮助。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack入门级篇章，看这篇就够了</title>
      <link href="/2019/03/27/webpack%E5%85%A5%E9%97%A8%E7%BA%A7%E7%AF%87%E7%AB%A0%EF%BC%8C%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/"/>
      <url>/2019/03/27/webpack%E5%85%A5%E9%97%A8%E7%BA%A7%E7%AF%87%E7%AB%A0%EF%BC%8C%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近由于要准备关于前端的分享课程，不知道要讲些什么，什么最重要，回想了一下，感觉什么都比较重要（哈哈哈），思来想去还是觉得讲一下《webpack自动化打包》，为什么呢，因为webpack如日中天，哈哈，不扯淡了，下面进入正题。</p><h3 id="Webpack到底是什么鬼"><a href="#Webpack到底是什么鬼" class="headerlink" title="Webpack到底是什么鬼"></a>Webpack到底是什么鬼</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;官方的概念：webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。通俗点理解就是你前端的东西，然后通过它将其打包为合适的格式以供浏览器使用，它火起来的原因是单页面的应用和js模块化，webpack提供了扩展的机制，在很多社区的支持下，在各个方面都得到了拓展和应用。</p><h3 id="Webpack和Gulp、Grunt有什么区别，为什么使用Webpack"><a href="#Webpack和Gulp、Grunt有什么区别，为什么使用Webpack" class="headerlink" title="Webpack和Gulp、Grunt有什么区别，为什么使用Webpack"></a>Webpack和Gulp、Grunt有什么区别，为什么使用Webpack</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;读了上面的，可能会有人问，不是有grunt和gulp的打包工具吗，他们也很好用啊，我觉得很好啊，其实webpack和另外两个没有可比性，不同之处：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gulp和grunt是一种能够优化前端的开发流程的工具，而webpack是一种模块化的解决方案。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gulp和grunt工作方式是在一个配置文件中，指明对某一些文件进行编译、组合、压缩等任务的具体步骤，然后它就可以帮助你去完成任务了，最大的问题就是不能不能按需打包，更别说按需加载，如果程序中用不到的文件，也会被打包进来；Webpack的工作方式是将你的整个项目当做一个整体，然后通过给定的一个配置文件，从这个文件开始找到你项目所依赖的文件，使用loaders处理它们，最后打包为一个浏览器可识别的JavaScript文件，如下图是工作方式：</p><p><img src="https://s2.ax1x.com/2019/03/27/AaK9Rx.png" alt="webpack工作模式"></p><h3 id="Webpack具有的特性"><a href="#Webpack具有的特性" class="headerlink" title="Webpack具有的特性"></a>Webpack具有的特性</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 对 CommonJS 、 AMD 、ES6的语法做了兼容<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对CoffeeScript、ES6的支持<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 有独立的配置文件webpack.config.js<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4. 可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5. 具有强大的Plugin接口，大多是内部插件，使用起来比较灵活</p><h3 id="Webpack-安装及使用"><a href="#Webpack-安装及使用" class="headerlink" title="Webpack 安装及使用"></a>Webpack 安装及使用</h3><p>首先全局安装webpack，进入终端就可以安装，安装目录如下：</p><pre><code class="bash">    npm install -g webpack  //全局安装webpack</code></pre><p>在一个本地新建一个文件夹webpackdemo，在终端转到该文件夹下，输入如下命令：</p><pre><code class="bash">    npm init //这个命令是让你配置一些初始得到信息，例如项目名称、入口文件，作者等</code></pre><p>完成上述以后，你的基础信息配置完成，安装局部的webpack，命令如下：</p><pre><code class="bash">    npm install --save-dev webpack</code></pre><p>完成上述步骤，应该会有如下文件：</p><ul><li>node_modules:依赖包文件</li><li>package-lock.json:当 node_modules 或 package.json 发生变化时自动生成的文件.这个文件主要功能是确定当前安装的包的依赖，以便后续重新安装的时候生成相同的依赖，而忽略项目开发过程中有些依赖已经发生的更新</li><li>package.json:刚开始配置的基础信息，以后依赖的安装包名称都会这里</li></ul><p>回到之前的那个空的文件夹内，建立如下图所示文件以及文件夹：<br><img src="https://s2.ax1x.com/2019/03/27/AaKpJ1.png" alt="文件夹目录"></p><ul><li><p>app文件夹是我们的基础文件夹</p></li><li><p>public是展示的文件夹</p></li><li><p>webpack.config.js是我们的脚本配置文件</p></li><li><p>hello.js</p><pre><code class="JavaScript">  //hello.js  var config = require(&#39;../config.json&#39;)  module.exports = {      sayhello: function () {          console.log(config.world);      }  }</code></pre></li><li><p>config.json</p><pre><code class="json">  //config.json  {      &quot;world&quot;: &quot;hello world!&quot;  }</code></pre></li><li><p>main.js</p><pre><code class="JavaScript">  //main.js  var a = require(&#39;./hello.js&#39;);  a.sayhello();</code></pre></li><li><p>index.html</p><pre><code class="html">  //index.html  &lt;!DOCTYPE html&gt;  &lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;      &lt;meta charset=&quot;UTF-8&quot;&gt;      &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;      &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;      &lt;title&gt;webpack&lt;/title&gt;      &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;  &lt;/body&gt;  &lt;/html&gt;</code></pre></li><li><p>bundle.js: 打包以后生成的文件</p></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 开始第一次打包，一般的命令如下:</p><pre><code class="bash">    webpack app/js/main.js public/bundle.js //webpack 入口文件 输入文件</code></pre><p><img src="https://s2.ax1x.com/2019/03/27/AaKCz6.png" alt="打包出错"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 结果出现了上述红色的错误信息，查明原因是因为我们webpack的版本太高了，使用如下命令：webpack app/js/main.js -o public/bundle.js</p><p><img src="https://s2.ax1x.com/2019/03/27/Aauxo9.png" alt="打包"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 看到如图结果红色的错误信息没有了，出现了黄色的警告信息，经过研究表明，webpack有3中模式,有开发模式（develpoment）,生产模式（production）,无这三个状态，使用命令webpack app/js/main.js -o public/bundle.js –mode develpoment，如下图所示：</p><p><img src="https://s2.ax1x.com/2019/03/27/AaKSiR.png" alt="打包"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hash代表产生的的hash值；version代表目前的webpack的版本；time是打包所用的时间；built at 完成的时间；asseet是产生的文件；size生成文件的大小；chunks是打包的分块；chunk names是打包名称；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 现在看你的项目里面，publick文件夹下面是不是多了一个bundle.js文件，打开一看和我们原来的差不多，是没有压缩的文件，如果用app/js/main.js -o public/bundle.js –modeproduction命令，生成的文件是是压缩过的文件。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果进行到了这里，那你就成功了，哈哈，是不是很简单，只要细心分析，肯定可以的</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 但是你有没有发现，难道我每次打包处理文件，都要这样去敲命令行，还这么多信息要输入，答案肯定会的，下面我们进行配置webpack.comfig.js（最开始创建文件时已经创建）,如下代码：</p><pre><code class="JavaScript">    module.exports = {        entry: __dirname + &quot;/app/js/main.js&quot;, //唯一入口文件        output: {            path: __dirname + &quot;/public&quot;, //打包后的文件存放的地方            filename: &quot;bundle.js&quot; //打包后输出文件的文件名        }    }    //“__dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录，你可写，也可去掉</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们运行命令：webpack，如图：</p><p><img src="https://s2.ax1x.com/2019/03/27/AaKVdH.png" alt="webpack打包"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 看到了产生了bundle.js，但是有黄色的信息警告，我们仔细一看是，没有配置模式，打开webpack.config.js，添加代码：</p><pre><code class="JavaScript">    module.exports = {        entry: __dirname + &quot;/app/js/main.js&quot;, //唯一入口文件        output: {            path: __dirname + &quot;/public&quot;, //打包后的文件存放的地方            filename: &quot;bundle.js&quot; //打包后输出文件的文件名        },        mode: &#39;development&#39; // 设置mode    }</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 然后运行webpack，发现了没有黄色的警告信息<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 另一种打包方式,配置package.json:</p><pre><code class="json">    &quot;scripts&quot;: {        &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,        &quot;start&quot;: &quot;webpack&quot;    }</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 运行命令：npm start ，和上述webpack命令一样</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 注：上述的两种打包都是在全局安装的几种情况下打包的 ，非全局打包:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1. node_modules/ .bin/webpack app/js/main.js public/bundle.js<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2. 配置package.json，运行命令：npm start</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; package.json中的script会安装一定顺序寻找命令对应位置，本地的node_modules/.bin路径就在这个寻找清单中，所以无论是全局还是局部安装的Webpack，你都不需要写前面那指明详细的路径了。</p><h3 id="强大的调试功能（生成Source-Maps）"><a href="#强大的调试功能（生成Source-Maps）" class="headerlink" title="强大的调试功能（生成Source Maps）"></a>强大的调试功能（生成Source Maps）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 开发总是离不开调试，方便的调试能极大的提高开发效率，不过有时候通过打包后的文件，你是不容易找到出错了的地方，对应的你写的代码的位置的，Source Maps就是来帮我们解决这个问题的.</p><table><thead><tr><th align="left">devtool选项</th><th align="left">配置结果</th></tr></thead><tbody><tr><td align="left">source-map</td><td align="left">在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包速度；</td></tr><tr><td align="left">cheap-module-source-map</td><td align="left">在一个单独的文件中生成一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便；</td></tr><tr><td align="left">eval-source-map</td><td align="left">使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项；</td></tr><tr><td align="left">cheap-module-eval-source-map</td><td align="left">这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点；方法构建速度更快，但是不利于</td></tr></tbody></table><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 上述选项由上到下打包速度越来越快，不过同时也具有越来越多的负面作用，较快的打包速度的后果就是对打包后的文件的的执行有一定影响。</p><h3 id="Webpack搭建本地服务"><a href="#Webpack搭建本地服务" class="headerlink" title="Webpack搭建本地服务"></a>Webpack搭建本地服务</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Webpack搭建本地的服务器，可以监听你修改的代码，并刷新显示修改后的结果，服务器是基于node.js构建，首先要装它的依赖：</p><pre><code class="bash">    npm install --save-dev webpack-dev-server</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 以下是服务器的配置选择，具体点击<a href="https://webpack.js.org/configuration/dev-server/" target="_blank" rel="noopener">了解更多</a></p><table><thead><tr><th align="left">devserver的配置选项</th><th align="left">功能描述</th></tr></thead><tbody><tr><td align="left">contentBase</td><td align="left">默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录（本例设置到“public”目录）</td></tr><tr><td align="left">port</td><td align="left">设置默认监听端口，如果省略，默认为”8080“</td></tr><tr><td align="left">inline</td><td align="left">设置为true，当源文件改变时会自动刷新页面</td></tr><tr><td align="left">historyApiFallback</td><td align="left">在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html</td></tr></tbody></table><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在webpack.config.js中配置devserver</p><pre><code class="JavaScript">    module.exports = {        devtool: &#39;eval-source-map&#39;,        entry: __dirname + &quot;/app/js/main.js&quot;, //唯一入口文件        output: {            path: __dirname + &quot;/public&quot;, //打包后的文件存放的地方            filename: &quot;bundle.js&quot; //打包后输出文件的文件名        },        mode: &#39;development&#39;, // 设置mode        devServer: {            contentBase: &quot;./public&quot;, //本地服务器所加载的页面所在的目录            historyApiFallback: true, //不跳转            inline: true //实时刷新        }    }</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在package.json中配置script：</p><pre><code class="json">    &quot;scripts&quot;: {        &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,        &quot;start&quot;: &quot;webpack&quot;,        &quot;server&quot;: &quot;webpack-dev-server --open&quot;    }</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在终端输入npm run server ,如下图所示，已经启动成功，并且会打开浏览器：</p><p><img src="https://s2.ax1x.com/2019/03/27/AaKiQK.png" alt="webpack服务启动"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 运行结果：</p><p><img src="https://s2.ax1x.com/2019/03/27/AaKZod.png" alt="运行结果"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们修改一下config.js文件，内容改为I come from china，如下如。终端显示：</p><p><img src="https://s2.ax1x.com/2019/03/27/AaKFsO.png" alt="终端运行结果"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 已经编译完成，生成新的文件bundle.js，然后看看浏览器，如图</p><p><img src="https://s2.ax1x.com/2019/03/27/AaKkLD.png" alt="浏览器结果"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  在控制台已经打印出修改的结果。</p><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Module 主要是用来配置加载器（Loaders），包括loaders、preLoaders、postLoaders、noParse。webpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件，就需要使用 loader 进行转换。</p><h3 id="Loaders"><a href="#Loaders" class="headerlink" title="Loaders"></a>Loaders</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Loaders需要单独安装并且需要在webpack.config.js中的modules关键字下进行配置，Loaders的配置包括以下几方面：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; test：一个用以匹配loaders所处理文件的拓展名的正则表达式（必须）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loader：loader的名称（必须）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; query：为loaders提供额外的设置选项（可选）</p><h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Babel其实是一个编译JavaScript的平台，让你能使用最新的JavaScript代码（ES6，ES7…），而不用管新标准是否被当前使用的浏览器完全支持，让你能使用基于JavaScript进行了拓展的语言，比如React的JSX。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  如何安装Babel并且配置</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，webpack可以把其不同的包整合在一起使用，对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析Es6的babel-env-preset包和解析JSX的babel-preset-react包）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  如下命令安装：</p><pre><code class="bash">    // npm一次性安装多个依赖模块，模块之间用空格隔开    npm install --save-dev babel-core babel-loader babel-preset-env babel-preset-react</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  配置webpack.config.js</p><pre><code class="JavaScript">    module.exports = {        devtool: &#39;eval-source-map&#39;,        entry: __dirname + &quot;/app/js/main.js&quot;, //唯一入口文件        output: {            path: __dirname + &quot;/public&quot;, //打包后的文件存放的地方            filename: &quot;bundle.js&quot; //打包后输出文件的文件名        },        mode: &#39;development&#39;, // 设置mode        devServer: {            contentBase: &quot;./public&quot;, //本地服务器所加载的页面所在的目录            historyApiFallback: true, //不跳转            inline: true //实时刷新        },        module: {            rules: [{                test: /(\.jsx|\.js)$/,                use: {                    loader: &quot;babel-loader&quot;,                    options: {                        presets: [                            &quot;env&quot;, &quot;react&quot;                        ]                    }                },                exclude: /node_modules/            }]        }    }</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如上述代码，webapck已允许支持了es6和jsx语法，所以后续我们会用react，所以要安装react需要的配置信息。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 终端安装：</p><pre><code class="bash">    npm install --save react react-dom</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 更改hello.js,返回一个react的组件</p><pre><code class="JavaScript">    import React,{Component} from &#39;react&#39;    import config from &#39;./config.json&#39;    class hello extends Component {        render() {            return (                &lt;div &gt;                    {config.world}                &lt;/div&gt;            )        }    }    export default hello</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 更改main.js，渲染hello模块</p><pre><code class="JavaScript">    import React from &#39;react&#39;    import {render} from &#39;react-dom&#39;    import Hello from &#39;./hello&#39;    render(&lt;Hello /&gt;, document.getElementById(&#39;root&#39;));</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 更改public/index.html,添加</p><pre><code class="html">    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code></pre><p>运行npm run server,出现了2处错误，第一处：</p><p><img src="https://s2.ax1x.com/2019/03/27/AaKnJI.png" alt="报错信息"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  如上图看出，是版本出现了问题，打开package.json，发现babel-core的版本是6.26.3，凡是babel-loader的版本是8.X，并且提示了如果要用babel-core 的6.X版本，所以要装babel-loader的7.X的版本，所以运行终端:nom install –save-dev babel-loader@7  , 然后在运行npm run server，发现终端没有错误了，但是浏览器报错了，如图：</p><p><img src="https://s2.ax1x.com/2019/03/27/AaKEee.png" alt="报错信息"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 仔细分析，原来是我们的js引入有问题，我将webpack生成的js文件放在了head，此时DOM还没有建立完毕，因此出现 not a DOM element 的错误，所以将bundle.js文件放在HTML底部就可以了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 然后运行，发现成功了，没有报错的信息，浏览器所示：</p><p><img src="https://s2.ax1x.com/2019/03/27/AaKmFA.png" alt="成功信息"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由于Babel在webpack.config.js里配置，考虑到babel具有非常多的配置选项，并且会使webpack.config.js的文件越来越复杂，所以我们单独新建一个文件”.babelrc”,和webpack.config.js在同一级，如图所示更改：</p><p><img src="https://s2.ax1x.com/2019/03/27/AaKuWt.png" alt="配置信息"></p><h3 id="CSS模块"><a href="#CSS模块" class="headerlink" title="CSS模块"></a>CSS模块</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Webpack有两个依赖包来处理样式表（css-loader 和 style-loader），这里我们只引入css文件（不引入sass和less，因为和css引入方式相同），二者的处理方式不同：</p><ul><li><p>style-loader：style-loader能够在需要载入的html中创建一个<style></style>标签，标签里的内容就是CSS内容</p></li><li><p>css-loader：css-loader是允许在js中import一个css文件，会将css文件当成一个模块引入到js文件中</p></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 安装（css-loader和 style-loader）</p><pre><code class="bash">    npm install --save-dev style-loader css-loader</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  在css文件夹中创建main.css,并输入如下内容：</p><pre><code class="css">    body {        margin: 0;        font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif;        font-size: 18px;        background-color: beige;    }    h1, h2, h3, h4, h5, h6, p, ul {        margin: 0;        padding: 0;    }</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在主入口文件（main.js）中导入main.css</p><pre><code class="JavaScript">    import React from &#39;react&#39;    import {render} from &#39;react-dom&#39;    import Hello from &#39;./hello&#39;    import &#39;../css/main.css&#39; // 导入css    render(&lt;Hello /&gt;, document.getElementById(&#39;root&#39;));</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 运行npm start,发现你加入的css文件已经被引入了，并且生效了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 那这里有出现一个问题，大多数的样式表，都有很多的全局变量名称，每个开发者都有可能写两个或者以上的相同的名称，以后的维护和修改都比较困难，怎么去避免全局变量名的污染等，答案是肯定可以的，引入了css module，有兴趣可以访问<a href="https://github.com/css-modules/css-modules" target="_blank" rel="noopener">官方文档</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Css module技术是把JS的模块化思想带入CSS中来，通过CSS模块，所有的类名，动画名默认都只作用于当前模块。Webpack对CSS模块化提供了非常好的支持，只需要在CSS loader中进行简单配置即可，然后就可以直接把CSS的类名传递到组件的代码中，这样做有效避免了全局污染。下面我们进行配置：</p><pre><code class="JavaScript">    {// 指定启用css modules        test: /\.css$/,        use: [            {                loader: &quot;style-loader&quot;            }, {                loader: &quot;css-loader&quot;,                options: {                modules: true, // 指定启用css modules                localIdentName: &#39;[name]__[local]--[hash:base64:5]&#39; // 指定css的类名格式                }            }        ]    }</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  在css文件夹中创建 hello.css，加入如下代码：</p><pre><code class="css">    .rootchild{        font-size: 20px;        color:red;    }</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  hello.js更改如下：</p><pre><code class="JavaScript">    import React,{Component} from &#39;react&#39;    import config from &#39;./config.json&#39;    import helloone from &#39;../css/hello.css&#39; //引入css    class hello extends Component {        render() {            return (                &lt;div className={helloone.rootchild}&gt; {/* className 是添加类名 */}                    {config.world}                &lt;/div&gt;            )        }    }    export default hello</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  运行npm start，如图所示：发现字体的颜色发生了变化，并且类名也发生了变化，这样相同的类名也不会造成不同组件之间的污染。</p><p><img src="https://s2.ax1x.com/2019/03/27/AaKQQf.png" alt="css组件"></p><h3 id="插件学习（Plugins）"><a href="#插件学习（Plugins）" class="headerlink" title="插件学习（Plugins）"></a>插件学习（Plugins）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  插件是webpack的拓展功能，作用于整个构建的过程，很多人把loader和插件分不清楚，你只要记住，loader是处理源文件的，一次处理一个，而插件不处理单个文件，是处理整个项目的构成，webpack有很多的内置插件，也有很多的第三方插件，如果是第三方，是需要手动去安装，再引用</p><p><img src="https://s2.ax1x.com/2019/03/27/AaKly8.png" alt="插件"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  红色的部分是添加的部分，如图打包以后：</p><p><img src="https://s2.ax1x.com/2019/03/27/AaKMSP.png" alt="打包产生"></p><h3 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  这个插件的作用是依据一个简单的index.html模板，生成一个自动引用你打包后的JS文件的新index.html。这在每次生成的js文件名称不同时非常有用（比如添加了hash值）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   先对原来的文件夹进行一些改动：移除public文件夹，在app文件夹下创建一个index.tmpl.html的文件模板，在使用插件的时候，会自动依据模板生成一个新的index.html。Index.tmpl.html 模板如下</p><pre><code class="html">    &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;        &lt;title&gt;webpack&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;    &lt;/body&gt;    &lt;/html&gt;</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  安装HtmlWebpackPlugin</p><pre><code class="bash">    npm install --save-dev html-webpack-plugin</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  更新配置（webpack.config.js）：</p><pre><code class="JavaScript">    const webpack = require(&#39;webpack&#39;);    const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);    module.exports = {        devtool: &#39;eval-source-map&#39;,        entry: __dirname + &quot;/app/js/main.js&quot;, //唯一入口文件        output: {            path: __dirname + &quot;/build&quot;, //打包后的文件存放的地方            filename: &quot;bundle.js&quot; //打包后输出文件的文件名        },        mode: &#39;development&#39;, // 设置mode        devServer: {            contentBase: __dirname + &#39;./build&#39;, //本地服务器所加载的页面所在的目录            historyApiFallback: true, //不跳转            inline: true //实时刷新        },        module: {            rules: [{                    test: /(\.jsx|\.js)$/,                    use: {                        loader: &quot;babel-loader&quot;                    },                    exclude: /node_modules/                },                {                    test: /\.css$/,                    use: [{                        loader: &quot;style-loader&quot;                    }, {                        loader: &quot;css-loader&quot;,                        options: {                            modules: true, // 指定启用css modules                            localIdentName: &#39;[name]__[local]--[hash:base64:5]&#39; // 指定css的类名格式                        }                    }]                }            ]        },        plugins: [            new webpack.BannerPlugin(&#39;版权所有，翻版必究&#39;),            new HtmlWebpackPlugin({                template: __dirname + &quot;/app/index.tmpl.html&quot; //new 一个这个插件的实例，并传入相关的参数            })        ]    }</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  引入插件名称，修改输出地址，在plugins里添加,运行npm start</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  发现文件夹里多了一个build的文件夹，打开文件，发现有一个index.html和build.js文件。用浏览器打开index.html，发现和原来public文件夹里的事一样的，这样打包更加的方便。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  如果你要实时更新你的代码，一定要配置好服务的内容devServer。</p><h3 id="优化插件"><a href="#优化插件" class="headerlink" title="优化插件"></a>优化插件</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; webpack提供了一些在发布阶段非常有用的优化插件，它们大多来自于webpack社区，可以通过npm安装，通过以下插件可以完成产品发布阶段所需的功能</p><ul><li>OccurenceOrderPlugin :为组件分配ID，通过这个插件webpack可以分析和优先考虑使用最多的模块，并为它们分配最小的ID</li><li>UglifyJsPlugin：压缩JS代码，这个因为高版本的需求，已经不用这个插件了（下面的配置中，我会配置）</li><li>ExtractTextPlugin：分离CSS和JS文件</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由于第一个和第二个是内置插件，只要引入就可以了，但是后面分离css和js，需要安装插件：</p><pre><code class="bash">    npm install --save-dev extract-text-webpack-plugin@next</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  为什么要加@next，因为extract-text-webpack-plugin目前版本不支持webpack4，下面是配置了组件分配Id，压缩js，分离了css和js：</p><pre><code class="javascript">    const webpack = require(&#39;webpack&#39;);    const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);    const ExtractTextPlugin = require(&#39;extract-text-webpack-plugin&#39;);    module.exports = {        devtool: &#39;eval-source-map&#39;,        entry: __dirname + &quot;/app/js/main.js&quot;, //唯一入口文件        output: {            path: __dirname + &quot;/build&quot;, //打包后的文件存放的地方            filename: &quot;bundle.js&quot; //打包后输出文件的文件名        },        mode: &#39;development&#39;, // 设置mode        devServer: {            contentBase: __dirname + &#39;./build&#39;, //本地服务器所加载的页面所在的目录            historyApiFallback: true, //不跳转            inline: true //实时刷新        },        module: {            rules: [{                    test: /(\.jsx|\.js)$/,                    use: {                        loader: &quot;babel-loader&quot;                    },                    exclude: /node_modules/                },                {                    test: /\.css$/,                    use: ExtractTextPlugin.extract({                        fallback: &quot;style-loader&quot;,                        use: [{                            loader: &quot;css-loader&quot;,                            options: {                                modules: true,                                localIdentName: &#39;[name]__[local]--[hash:base64:5]&#39;                            }                        }]                    })                }            ]        },        plugins: [            new webpack.BannerPlugin(&#39;版权所有，翻版必究&#39;),            new HtmlWebpackPlugin({                template: __dirname + &quot;/app/index.tmpl.html&quot; //new 一个这个插件的实例，并传入相关的参数            }),            new webpack.optimize.OccurrenceOrderPlugin(),            new ExtractTextPlugin(&quot;style.css&quot;)        ],        /* 压缩js代码 */        optimization: {            minimize: true        }    }    //“__dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录。</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  运行npm start ，发现build文件夹里多出了style.css。</p><h3 id="引入图片"><a href="#引入图片" class="headerlink" title="引入图片"></a>引入图片</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  首先还是要装插件，终端：</p><pre><code class="bash">    npm install --save-dev url-loader</code></pre><p>Hello.css</p><pre><code class="css">    .rootchild{        font-size: 20px;        color:red;        background-image: url(&#39;../img/hello.jpg&#39;);        width: 197px;        height: 197px;    }</code></pre><p>Webpack.config.js</p><pre><code class="javascript">    {        test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,        loader: &#39;url-loader?limit=8192&amp;name=img/[hash:8].[name].[ext]&#39;    }</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  运行代码：npm start ，浏览器打开build文件夹下的index.html，如图:</p><p><img src="https://s2.ax1x.com/2019/03/27/AaK1OS.png" alt="图片展示"></p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  写完这篇文章，想起当时搞这个基础配置，也花费了几天的时间，总是搞不好，版本的问题，配置问题，反正各种问题，也是各个博客去看自己错在什么地方，搞的人头都大了，总之当时功夫不负有心人，当时是成功了。这篇文章是比较基础的，对于新手入门还是很重要，只要按照流程，还是很容易的搭建出来，文章里有很多容易出错的点，我也列举出来了，对于点的介绍都很全面，如果看到这里，说明你已经基本入门了，可以很好地去了解其他关于webpack的知识点。</p><p>本文的代码在这里<a href="https://github.com/jsocean/webpackbasic" target="_blank" rel="noopener">webpackbasic</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> webpack </tag>
            
            <tag> 自动化打包 </tag>
            
            <tag> CMD AMD ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前后端分离的重要思想</title>
      <link href="/2019/03/18/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%9D%E6%83%B3/"/>
      <url>/2019/03/18/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这几天我的同事分享一篇前端发展的简史，并提到了前后端分离这样的一种概念，我想对于目前的web来说，前后端的分离已经变得越来越流行，也是以后web发展的一种趋势，而这篇文章也是我对前后端分离的一些个人的想法。</p><h3 id="为什么选择前后端分离"><a href="#为什么选择前后端分离" class="headerlink" title="为什么选择前后端分离"></a>为什么选择前后端分离</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;传统的前端就是拿到设计图，然后切图，用html，css，js写成demo的页面，然后交给后台的人员，后台的人员去实现数据的交互，如果显示问题，又交给前台去修改等等问题，都需要前后端时刻的去配合完成，甚至有些后台人员要兼顾前端的工作，一边写着后台的接口，一边要拼接url的动态的地址，这也就暴露出了很多的问题，前后端的工作分配不均，开发的效率慢，代码难以维护等。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前后端分离的根本思想就是把数据和页面分离，前后端之间约定好json的数据格式，后台就专注自己的逻辑，提供相应的接口；前端开发人员则可以利用webpack或者nodejs来搭建自己的本地服务器，直接在本地开发。两者都可以同时开工，不互相依赖，开发效率更快，而且分工比较均衡。<br><img src="https://s2.ax1x.com/2019/03/24/AY5KK0.png" alt="前后代码分离模式"></p><h3 id="前后端分离以后的开发模式"><a href="#前后端分离以后的开发模式" class="headerlink" title="前后端分离以后的开发模式"></a>前后端分离以后的开发模式</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前后端分离以后，整个的流程更加的清晰，双方各不干扰，如下图所示：<br><img src="https://s2.ax1x.com/2019/03/24/AY5m2n.png" alt="前后开发模式"></p><h3 id="前后端数据接口的规范流程"><a href="#前后端数据接口的规范流程" class="headerlink" title="前后端数据接口的规范流程"></a>前后端数据接口的规范流程</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上图中可以了解到，前后端是并行开发，但是具体是怎样的流程呢，如下图</p><p><img src="https://s2.ax1x.com/2019/03/24/AY5nvq.png" alt="前后开发模式"></p><h3 id="个人心得与体会"><a href="#个人心得与体会" class="headerlink" title="个人心得与体会"></a>个人心得与体会</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前后端分离以后，确实是方便了很多，以前由后台控制路由、后台渲染页面到现在的前端控制路由、前端渲染数据，工作流程和方式都发生了很大的变化，思想发生了很大的变化：</p><ul><li>彻底的解放了前端的开发</li><li>再也不需要后台给我配置服务器了</li><li>提高了整个项目的开发效率</li><li>页面跳转更快，局部渲染加载速度快很多</li><li>页面模板可以重复的使用，前端组件化开发提高了开发效率</li><li>降低了项目的维护的成本</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前后端分离的开发模式与传统模式相比，让我们有规划地打造一个前后端并重的精益开发 团队，更好地应对越来越复杂多变的Web应用开发需求。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 前端分离 </tag>
            
            <tag> 思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怎么去理解JavaScript中的闭包原理</title>
      <link href="/2019/03/13/%E6%80%8E%E4%B9%88%E5%8E%BB%E7%90%86%E8%A7%A3JavaScript%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%E5%8E%9F%E7%90%86/"/>
      <url>/2019/03/13/%E6%80%8E%E4%B9%88%E5%8E%BB%E7%90%86%E8%A7%A3JavaScript%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天搭建好了自己的博客，以前是觉得写博客没什么用（还是太年轻了！！！）,其实并不然，它可以让你当时很好的去理解某一个知识点，并且组织语言写出来，惠及他人，后面回过头再看你自己写的代码，可以从中找出相应的不足（我想应该是很多程序猿的心声）。废话不多说了，这几天在写插件的过程中遇到了闭包的问题，比以前初学时理解的更深刻了，下面进入我们今天的主题，怎么去<code>理解JavaScript中的闭包原理</code>。</p><h3 id="什么是闭包，怎么去理解它"><a href="#什么是闭包，怎么去理解它" class="headerlink" title="什么是闭包，怎么去理解它"></a>什么是闭包，怎么去理解它</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;闭包，官方的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分，这样的解释，肯定是理解起来比较晦涩难懂的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大家都知道js作用域有两种，<code>局部和全局</code>,在作用域中访问的顺序是由内向外的，内部的作用域可以访问当前作用域和包含当前作用域的外层变量，那么相反就不能了，那么闭包的作用就体现出来了，就是<code>一个函数内部有权限去访问另外一个函数内部的变量，更通俗一点就是函数中的函数，并在外可以访问</code>,主要体现3点：</p><ul><li>闭包的外层是函数，内部也是函数</li><li>闭包内部会return一个函数</li><li>执行闭包后，闭包的内部变量会存在，闭包内部函数的内部变量会回收</li></ul><h3 id="举例让你更加的明白什么是闭包"><a href="#举例让你更加的明白什么是闭包" class="headerlink" title="举例让你更加的明白什么是闭包"></a>举例让你更加的明白什么是闭包</h3><pre><code class="javascript">    function man() {        var str = &quot;hello world!&quot;        function woman() {            console.log(str);        }        return woman;    }    var person = man();    person();  // hello world!</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看到上面的例子，是不是大脑里已经把闭包的画面过了一遍，总结上面的一句话就是<code>函数man里面有一个函数woman被函数man外的变量person引用</code>。</p><pre><code class="javascript">    function man() {        var money = 1;        function woman() {            var num = 0;            console.log(++num);            console.log(++money);        }        return woman;    }    var person = man();    person();  // 1 2    person();  // 1 3</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看上面这个例子，是一个比较经典的闭包例子，一般情况下在执行完man函数，里面的变量应该是被销毁的，但是woman函数作为man的函数给了person，就相当于执行了woman函数，并且woman函数引用了man函数的变量money，所以无法被销毁，而num每次被调用，都是num = 0，所以就产生了内存的消耗。</p><pre><code class="javascript">var person = function(){    //变量作用域为函数内部，外部无法访问        var name = &quot;one&quot;;    return {       getName : function(){           return name;       },       setName : function(newName){           name = newName;       }    }}();console.log(person.name);//直接访问，结果为undefinedconsole.log(person.getName());//oneconsole.log(person.setName(&quot;two&quot;)); //undefinedconsole.log(person.getName());//two  </code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看到上面的例子，是对闭包的优化，可能其他的都好理解，就第三个结果为什么是undefined，你们看setName函数，里面是没有return的。</p><h3 id="闭包的好处以及合理使用闭包"><a href="#闭包的好处以及合理使用闭包" class="headerlink" title="闭包的好处以及合理使用闭包"></a>闭包的好处以及合理使用闭包</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显而易见，闭包会保护函数内的变量安全，实现封装，防止与其他的变量名发生冲突，合理的使用闭包，防止消耗了内存，第二个例子，被引用的变量不能被销毁，增大了内存的消耗，造成内存的遗漏，浏览器性能问题等。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大家看了应该对闭包有所理解了吧，文字信息和例子相结合，应该很快会明白什么是闭包，自己可以动动手，写写，应该会更深刻的了解闭包的含义，如果有什么错误，请告知，谢谢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 闭包原理 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
