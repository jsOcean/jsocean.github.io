<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><meta name="baidu-site-verification"><title>webpack入门级篇章，看这篇就够了 | JsOcean</title><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.png"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="JsOcean" type="application/atom+xml">
</head><link rel="stylesheet" type="text/css" href="/plugins/prettify/doxy.css"><script type="text/javascript" src="/js/ready.js" async></script><body class="night"><div class="mobile-head" id="mobile-head"><div class="navbar-icon"><span></span><span></span><span></span></div><div class="navbar-title"><a href="/">LITREILY</a></div><div class="navbar-search"><!--= show a circle here--></div></div><div class="h-wrapper" id="menu"><nav class="h-head box"><div class="m-hdimg"><a class="hdimg img" href="/"><img class="nofancybox" src="/img/profile.jpg" width="128" height="128"></a><h1 class="ttl"><a href="/">JsOcean</a></h1></div><p class="m-desc">人不奋斗,<br>和咸鱼有什么区别！</p><div class="m-nav"><ul><li><span class="dot">●</span><a href="/archives/">归档</a></li><li><span class="dot">●</span><a href="/categories/">分类</a></li><li><span class="dot">●</span><a href="/tags/">标签</a></li><li><span class="dot">●</span><a href="/about/">关于</a></li><li class="m-sch"><form class="form" id="j-formsch" method="get"><input class="txt" type="text" id="local-search-input" name="q" value="搜索" onfocus="if(this.value=='搜索'){this.value='';}" onblur="if(this.value==''){this.value='搜索';}"><input type="text" style="display:none;"></form></li></ul><div id="local-search-result"></div></div></nav></div><div id="back2Top"><a class="fa fa-arrow-up" title="Back to top" href="#"></a></div><div class="box" id="container"><div class="l-wrapper"><div class="l-content box"><div class="l-post l-post-art"><article class="p-art"><div class="p-header box"><h1 class="p-title">webpack入门级篇章，看这篇就够了</h1><div class="p-info"><span class="p-date"><i class="fa fa-calendar"></i><a href="/2019/03/27/webpack%E5%85%A5%E9%97%A8%E7%BA%A7%E7%AF%87%E7%AB%A0%EF%BC%8C%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/">2019-03-27</a></span><span class="p-view" id="busuanzi_container_page_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_page_pv"></span></span></div></div><div class="p-content"><h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近由于要准备关于前端的分享课程，不知道要讲些什么，什么最重要，回想了一下，感觉什么都比较重要（哈哈哈），思来想去还是觉得讲一下《webpack自动化打包》，为什么呢，因为webpack如日中天，哈哈，不扯淡了，下面进入正题。</p>
<h3 id="Webpack到底是什么鬼"><a href="#Webpack到底是什么鬼" class="headerlink" title="Webpack到底是什么鬼"></a>Webpack到底是什么鬼</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;官方的概念：webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。通俗点理解就是你前端的东西，然后通过它将其打包为合适的格式以供浏览器使用，它火起来的原因是单页面的应用和js模块化，webpack提供了扩展的机制，在很多社区的支持下，在各个方面都得到了拓展和应用。</p>
<h3 id="Webpack和Gulp、Grunt有什么区别，为什么使用Webpack"><a href="#Webpack和Gulp、Grunt有什么区别，为什么使用Webpack" class="headerlink" title="Webpack和Gulp、Grunt有什么区别，为什么使用Webpack"></a>Webpack和Gulp、Grunt有什么区别，为什么使用Webpack</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;读了上面的，可能会有人问，不是有grunt和gulp的打包工具吗，他们也很好用啊，我觉得很好啊，其实webpack和另外两个没有可比性，不同之处：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gulp和grunt是一种能够优化前端的开发流程的工具，而webpack是一种模块化的解决方案。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gulp和grunt工作方式是在一个配置文件中，指明对某一些文件进行编译、组合、压缩等任务的具体步骤，然后它就可以帮助你去完成任务了，最大的问题就是不能不能按需打包，更别说按需加载，如果程序中用不到的文件，也会被打包进来；Webpack的工作方式是将你的整个项目当做一个整体，然后通过给定的一个配置文件，从这个文件开始找到你项目所依赖的文件，使用loaders处理它们，最后打包为一个浏览器可识别的JavaScript文件，如下图是工作方式：</p>
<p><img src="https://s2.ax1x.com/2019/03/27/AaK9Rx.png" alt="webpack工作模式"></p>
<h3 id="Webpack具有的特性"><a href="#Webpack具有的特性" class="headerlink" title="Webpack具有的特性"></a>Webpack具有的特性</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 对 CommonJS 、 AMD 、ES6的语法做了兼容<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对CoffeeScript、ES6的支持<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 有独立的配置文件webpack.config.js<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4. 可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5. 具有强大的Plugin接口，大多是内部插件，使用起来比较灵活</p>
<h3 id="Webpack-安装及使用"><a href="#Webpack-安装及使用" class="headerlink" title="Webpack 安装及使用"></a>Webpack 安装及使用</h3><p>首先全局安装webpack，进入终端就可以安装，安装目录如下：</p>
<pre><code class="bash">    npm install -g webpack  //全局安装webpack</code></pre>
<p>在一个本地新建一个文件夹webpackdemo，在终端转到该文件夹下，输入如下命令：</p>
<pre><code class="bash">    npm init //这个命令是让你配置一些初始得到信息，例如项目名称、入口文件，作者等</code></pre>
<p>完成上述以后，你的基础信息配置完成，安装局部的webpack，命令如下：</p>
<pre><code class="bash">    npm install --save-dev webpack</code></pre>
<p>完成上述步骤，应该会有如下文件：</p>
<ul>
<li>node_modules:依赖包文件</li>
<li>package-lock.json:当 node_modules 或 package.json 发生变化时自动生成的文件.这个文件主要功能是确定当前安装的包的依赖，以便后续重新安装的时候生成相同的依赖，而忽略项目开发过程中有些依赖已经发生的更新</li>
<li>package.json:刚开始配置的基础信息，以后依赖的安装包名称都会这里</li>
</ul>
<p>回到之前的那个空的文件夹内，建立如下图所示文件以及文件夹：<br><img src="https://s2.ax1x.com/2019/03/27/AaKpJ1.png" alt="文件夹目录"></p>
<ul>
<li><p>app文件夹是我们的基础文件夹</p>
</li>
<li><p>public是展示的文件夹</p>
</li>
<li><p>webpack.config.js是我们的脚本配置文件</p>
</li>
<li><p>hello.js</p>
<pre><code class="JavaScript">  //hello.js
  var config = require(&#39;../config.json&#39;)

  module.exports = {
      sayhello: function () {
          console.log(config.world);
      }
  }</code></pre>
</li>
<li><p>config.json</p>
<pre><code class="json">  //config.json
  {
      &quot;world&quot;: &quot;hello world!&quot;
  }</code></pre>
</li>
<li><p>main.js</p>
<pre><code class="JavaScript">  //main.js
  var a = require(&#39;./hello.js&#39;);

  a.sayhello();</code></pre>
</li>
<li><p>index.html</p>
<pre><code class="html">  //index.html
  &lt;!DOCTYPE html&gt;
  &lt;html lang=&quot;en&quot;&gt;

  &lt;head&gt;
      &lt;meta charset=&quot;UTF-8&quot;&gt;
      &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
      &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
      &lt;title&gt;webpack&lt;/title&gt;
      &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;

  &lt;body&gt;
  &lt;/body&gt;

  &lt;/html&gt;</code></pre>
</li>
<li><p>bundle.js: 打包以后生成的文件</p>
</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 开始第一次打包，一般的命令如下:</p>
<pre><code class="bash">    webpack app/js/main.js public/bundle.js //webpack 入口文件 输入文件</code></pre>
<p><img src="https://s2.ax1x.com/2019/03/27/AaKCz6.png" alt="打包出错"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 结果出现了上述红色的错误信息，查明原因是因为我们webpack的版本太高了，使用如下命令：webpack app/js/main.js -o public/bundle.js</p>
<p><img src="https://s2.ax1x.com/2019/03/27/Aauxo9.png" alt="打包"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 看到如图结果红色的错误信息没有了，出现了黄色的警告信息，经过研究表明，webpack有3中模式,有开发模式（develpoment）,生产模式（production）,无这三个状态，使用命令webpack app/js/main.js -o public/bundle.js –mode develpoment，如下图所示：</p>
<p><img src="https://s2.ax1x.com/2019/03/27/AaKSiR.png" alt="打包"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hash代表产生的的hash值；version代表目前的webpack的版本；time是打包所用的时间；built at 完成的时间；asseet是产生的文件；size生成文件的大小；chunks是打包的分块；chunk names是打包名称；</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 现在看你的项目里面，publick文件夹下面是不是多了一个bundle.js文件，打开一看和我们原来的差不多，是没有压缩的文件，如果用app/js/main.js -o public/bundle.js –modeproduction命令，生成的文件是是压缩过的文件。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果进行到了这里，那你就成功了，哈哈，是不是很简单，只要细心分析，肯定可以的</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 但是你有没有发现，难道我每次打包处理文件，都要这样去敲命令行，还这么多信息要输入，答案肯定会的，下面我们进行配置webpack.comfig.js（最开始创建文件时已经创建）,如下代码：</p>
<pre><code class="JavaScript">    module.exports = {
        entry: __dirname + &quot;/app/js/main.js&quot;, //唯一入口文件
        output: {
            path: __dirname + &quot;/public&quot;, //打包后的文件存放的地方
            filename: &quot;bundle.js&quot; //打包后输出文件的文件名
        }
    }
    //“__dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录，你可写，也可去掉</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们运行命令：webpack，如图：</p>
<p><img src="https://s2.ax1x.com/2019/03/27/AaKVdH.png" alt="webpack打包"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 看到了产生了bundle.js，但是有黄色的信息警告，我们仔细一看是，没有配置模式，打开webpack.config.js，添加代码：</p>
<pre><code class="JavaScript">    module.exports = {
        entry: __dirname + &quot;/app/js/main.js&quot;, //唯一入口文件
        output: {
            path: __dirname + &quot;/public&quot;, //打包后的文件存放的地方
            filename: &quot;bundle.js&quot; //打包后输出文件的文件名
        },
        mode: &#39;development&#39; // 设置mode
    }</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 然后运行webpack，发现了没有黄色的警告信息<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 另一种打包方式,配置package.json:</p>
<pre><code class="json">
    &quot;scripts&quot;: {
        &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
        &quot;start&quot;: &quot;webpack&quot;
    }</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 运行命令：npm start ，和上述webpack命令一样</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 注：上述的两种打包都是在全局安装的几种情况下打包的 ，非全局打包:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1. node_modules/ .bin/webpack app/js/main.js public/bundle.js<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2. 配置package.json，运行命令：npm start</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; package.json中的script会安装一定顺序寻找命令对应位置，本地的node_modules/.bin路径就在这个寻找清单中，所以无论是全局还是局部安装的Webpack，你都不需要写前面那指明详细的路径了。</p>
<h3 id="强大的调试功能（生成Source-Maps）"><a href="#强大的调试功能（生成Source-Maps）" class="headerlink" title="强大的调试功能（生成Source Maps）"></a>强大的调试功能（生成Source Maps）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 开发总是离不开调试，方便的调试能极大的提高开发效率，不过有时候通过打包后的文件，你是不容易找到出错了的地方，对应的你写的代码的位置的，Source Maps就是来帮我们解决这个问题的.</p>
<table>
<thead>
<tr>
<th align="left">devtool选项</th>
<th align="left">配置结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">source-map</td>
<td align="left">在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包速度；</td>
</tr>
<tr>
<td align="left">cheap-module-source-map</td>
<td align="left">在一个单独的文件中生成一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便；</td>
</tr>
<tr>
<td align="left">eval-source-map</td>
<td align="left">使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项；</td>
</tr>
<tr>
<td align="left">cheap-module-eval-source-map</td>
<td align="left">这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点；方法构建速度更快，但是不利于</td>
</tr>
</tbody></table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 上述选项由上到下打包速度越来越快，不过同时也具有越来越多的负面作用，较快的打包速度的后果就是对打包后的文件的的执行有一定影响。</p>
<h3 id="Webpack搭建本地服务"><a href="#Webpack搭建本地服务" class="headerlink" title="Webpack搭建本地服务"></a>Webpack搭建本地服务</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Webpack搭建本地的服务器，可以监听你修改的代码，并刷新显示修改后的结果，服务器是基于node.js构建，首先要装它的依赖：</p>
<pre><code class="bash">    npm install --save-dev webpack-dev-server</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 以下是服务器的配置选择，具体点击<a href="https://webpack.js.org/configuration/dev-server/" target="_blank" rel="noopener">了解更多</a></p>
<table>
<thead>
<tr>
<th align="left">devserver的配置选项</th>
<th align="left">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">contentBase</td>
<td align="left">默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录（本例设置到“public”目录）</td>
</tr>
<tr>
<td align="left">port</td>
<td align="left">设置默认监听端口，如果省略，默认为”8080“</td>
</tr>
<tr>
<td align="left">inline</td>
<td align="left">设置为true，当源文件改变时会自动刷新页面</td>
</tr>
<tr>
<td align="left">historyApiFallback</td>
<td align="left">在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html</td>
</tr>
</tbody></table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在webpack.config.js中配置devserver</p>
<pre><code class="JavaScript">    module.exports = {
        devtool: &#39;eval-source-map&#39;,
        entry: __dirname + &quot;/app/js/main.js&quot;, //唯一入口文件
        output: {
            path: __dirname + &quot;/public&quot;, //打包后的文件存放的地方
            filename: &quot;bundle.js&quot; //打包后输出文件的文件名
        },
        mode: &#39;development&#39;, // 设置mode
        devServer: {
            contentBase: &quot;./public&quot;, //本地服务器所加载的页面所在的目录
            historyApiFallback: true, //不跳转
            inline: true //实时刷新
        }
    }</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在package.json中配置script：</p>
<pre><code class="json">    &quot;scripts&quot;: {
        &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
        &quot;start&quot;: &quot;webpack&quot;,
        &quot;server&quot;: &quot;webpack-dev-server --open&quot;
    }</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在终端输入npm run server ,如下图所示，已经启动成功，并且会打开浏览器：</p>
<p><img src="https://s2.ax1x.com/2019/03/27/AaKiQK.png" alt="webpack服务启动"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 运行结果：</p>
<p><img src="https://s2.ax1x.com/2019/03/27/AaKZod.png" alt="运行结果"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们修改一下config.js文件，内容改为I come from china，如下如。终端显示：</p>
<p><img src="https://s2.ax1x.com/2019/03/27/AaKFsO.png" alt="终端运行结果"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 已经编译完成，生成新的文件bundle.js，然后看看浏览器，如图</p>
<p><img src="https://s2.ax1x.com/2019/03/27/AaKkLD.png" alt="浏览器结果"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  在控制台已经打印出修改的结果。</p>
<h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Module 主要是用来配置加载器（Loaders），包括loaders、preLoaders、postLoaders、noParse。webpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件，就需要使用 loader 进行转换。</p>
<h3 id="Loaders"><a href="#Loaders" class="headerlink" title="Loaders"></a>Loaders</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Loaders需要单独安装并且需要在webpack.config.js中的modules关键字下进行配置，Loaders的配置包括以下几方面：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; test：一个用以匹配loaders所处理文件的拓展名的正则表达式（必须）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loader：loader的名称（必须）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; query：为loaders提供额外的设置选项（可选）</p>
<h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Babel其实是一个编译JavaScript的平台，让你能使用最新的JavaScript代码（ES6，ES7…），而不用管新标准是否被当前使用的浏览器完全支持，让你能使用基于JavaScript进行了拓展的语言，比如React的JSX。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  如何安装Babel并且配置</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，webpack可以把其不同的包整合在一起使用，对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析Es6的babel-env-preset包和解析JSX的babel-preset-react包）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  如下命令安装：</p>
<pre><code class="bash">    // npm一次性安装多个依赖模块，模块之间用空格隔开
    npm install --save-dev babel-core babel-loader babel-preset-env babel-preset-react</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  配置webpack.config.js</p>
<pre><code class="JavaScript">    module.exports = {
        devtool: &#39;eval-source-map&#39;,
        entry: __dirname + &quot;/app/js/main.js&quot;, //唯一入口文件
        output: {
            path: __dirname + &quot;/public&quot;, //打包后的文件存放的地方
            filename: &quot;bundle.js&quot; //打包后输出文件的文件名
        },
        mode: &#39;development&#39;, // 设置mode
        devServer: {
            contentBase: &quot;./public&quot;, //本地服务器所加载的页面所在的目录
            historyApiFallback: true, //不跳转
            inline: true //实时刷新
        },
        module: {
            rules: [{
                test: /(\.jsx|\.js)$/,
                use: {
                    loader: &quot;babel-loader&quot;,
                    options: {
                        presets: [
                            &quot;env&quot;, &quot;react&quot;
                        ]
                    }
                },
                exclude: /node_modules/
            }]
        }
    }</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如上述代码，webapck已允许支持了es6和jsx语法，所以后续我们会用react，所以要安装react需要的配置信息。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 终端安装：</p>
<pre><code class="bash">    npm install --save react react-dom</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 更改hello.js,返回一个react的组件</p>
<pre><code class="JavaScript">    import React,{Component} from &#39;react&#39;
    import config from &#39;./config.json&#39;

    class hello extends Component {
        render() {
            return (
                &lt;div &gt;
                    {config.world}
                &lt;/div&gt;
            )
        }
    }
    export default hello</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 更改main.js，渲染hello模块</p>
<pre><code class="JavaScript">    import React from &#39;react&#39;
    import {render} from &#39;react-dom&#39;
    import Hello from &#39;./hello&#39;

    render(&lt;Hello /&gt;, document.getElementById(&#39;root&#39;));</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 更改public/index.html,添加</p>
<pre><code class="html">    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code></pre>
<p>运行npm run server,出现了2处错误，第一处：</p>
<p><img src="https://s2.ax1x.com/2019/03/27/AaKnJI.png" alt="报错信息"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  如上图看出，是版本出现了问题，打开package.json，发现babel-core的版本是6.26.3，凡是babel-loader的版本是8.X，并且提示了如果要用babel-core 的6.X版本，所以要装babel-loader的7.X的版本，所以运行终端:nom install –save-dev babel-loader@7  , 然后在运行npm run server，发现终端没有错误了，但是浏览器报错了，如图：</p>
<p><img src="https://s2.ax1x.com/2019/03/27/AaKEee.png" alt="报错信息"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 仔细分析，原来是我们的js引入有问题，我将webpack生成的js文件放在了head，此时DOM还没有建立完毕，因此出现 not a DOM element 的错误，所以将bundle.js文件放在HTML底部就可以了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 然后运行，发现成功了，没有报错的信息，浏览器所示：</p>
<p><img src="https://s2.ax1x.com/2019/03/27/AaKmFA.png" alt="成功信息"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由于Babel在webpack.config.js里配置，考虑到babel具有非常多的配置选项，并且会使webpack.config.js的文件越来越复杂，所以我们单独新建一个文件”.babelrc”,和webpack.config.js在同一级，如图所示更改：</p>
<p><img src="https://s2.ax1x.com/2019/03/27/AaKuWt.png" alt="配置信息"></p>
<h3 id="CSS模块"><a href="#CSS模块" class="headerlink" title="CSS模块"></a>CSS模块</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Webpack有两个依赖包来处理样式表（css-loader 和 style-loader），这里我们只引入css文件（不引入sass和less，因为和css引入方式相同），二者的处理方式不同：</p>
<ul>
<li><p>style-loader：style-loader能够在需要载入的html中创建一个<style></style>标签，标签里的内容就是CSS内容</p>
</li>
<li><p>css-loader：css-loader是允许在js中import一个css文件，会将css文件当成一个模块引入到js文件中</p>
</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 安装（css-loader和 style-loader）</p>
<pre><code class="bash">    npm install --save-dev style-loader css-loader</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  在css文件夹中创建main.css,并输入如下内容：</p>
<pre><code class="css">    body {
        margin: 0;
        font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif;
        font-size: 18px;
        background-color: beige;
    }

    h1, h2, h3, h4, h5, h6, p, ul {
        margin: 0;
        padding: 0;
    }</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在主入口文件（main.js）中导入main.css</p>
<pre><code class="JavaScript">    import React from &#39;react&#39;
    import {render} from &#39;react-dom&#39;
    import Hello from &#39;./hello&#39;

    import &#39;../css/main.css&#39; // 导入css

    render(&lt;Hello /&gt;, document.getElementById(&#39;root&#39;));</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 运行npm start,发现你加入的css文件已经被引入了，并且生效了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 那这里有出现一个问题，大多数的样式表，都有很多的全局变量名称，每个开发者都有可能写两个或者以上的相同的名称，以后的维护和修改都比较困难，怎么去避免全局变量名的污染等，答案是肯定可以的，引入了css module，有兴趣可以访问<a href="https://github.com/css-modules/css-modules" target="_blank" rel="noopener">官方文档</a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Css module技术是把JS的模块化思想带入CSS中来，通过CSS模块，所有的类名，动画名默认都只作用于当前模块。Webpack对CSS模块化提供了非常好的支持，只需要在CSS loader中进行简单配置即可，然后就可以直接把CSS的类名传递到组件的代码中，这样做有效避免了全局污染。下面我们进行配置：</p>
<pre><code class="JavaScript">    {// 指定启用css modules
        test: /\.css$/,
        use: [
            {
                loader: &quot;style-loader&quot;
            }, {
                loader: &quot;css-loader&quot;,
                options: {
                modules: true, // 指定启用css modules
                localIdentName: &#39;[name]__[local]--[hash:base64:5]&#39; // 指定css的类名格式
                }
            }
        ]
    }</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  在css文件夹中创建 hello.css，加入如下代码：</p>
<pre><code class="css">    .rootchild{
        font-size: 20px;
        color:red;
    }</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  hello.js更改如下：</p>
<pre><code class="JavaScript">    import React,{Component} from &#39;react&#39;
    import config from &#39;./config.json&#39;

    import helloone from &#39;../css/hello.css&#39; //引入css

    class hello extends Component {
        render() {
            return (
                &lt;div className={helloone.rootchild}&gt; {/* className 是添加类名 */}
                    {config.world}
                &lt;/div&gt;
            )
        }
    }
    export default hello</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  运行npm start，如图所示：发现字体的颜色发生了变化，并且类名也发生了变化，这样相同的类名也不会造成不同组件之间的污染。</p>
<p><img src="https://s2.ax1x.com/2019/03/27/AaKQQf.png" alt="css组件"></p>
<h3 id="插件学习（Plugins）"><a href="#插件学习（Plugins）" class="headerlink" title="插件学习（Plugins）"></a>插件学习（Plugins）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  插件是webpack的拓展功能，作用于整个构建的过程，很多人把loader和插件分不清楚，你只要记住，loader是处理源文件的，一次处理一个，而插件不处理单个文件，是处理整个项目的构成，webpack有很多的内置插件，也有很多的第三方插件，如果是第三方，是需要手动去安装，再引用</p>
<p><img src="https://s2.ax1x.com/2019/03/27/AaKly8.png" alt="插件"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  红色的部分是添加的部分，如图打包以后：</p>
<p><img src="https://s2.ax1x.com/2019/03/27/AaKMSP.png" alt="打包产生"></p>
<h3 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  这个插件的作用是依据一个简单的index.html模板，生成一个自动引用你打包后的JS文件的新index.html。这在每次生成的js文件名称不同时非常有用（比如添加了hash值）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   先对原来的文件夹进行一些改动：移除public文件夹，在app文件夹下创建一个index.tmpl.html的文件模板，在使用插件的时候，会自动依据模板生成一个新的index.html。Index.tmpl.html 模板如下</p>
<pre><code class="html">    &lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
        &lt;title&gt;webpack&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
    &lt;/body&gt;
    &lt;/html&gt;</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  安装HtmlWebpackPlugin</p>
<pre><code class="bash">    npm install --save-dev html-webpack-plugin</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  更新配置（webpack.config.js）：</p>
<pre><code class="JavaScript">    const webpack = require(&#39;webpack&#39;);
    const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
    module.exports = {
        devtool: &#39;eval-source-map&#39;,
        entry: __dirname + &quot;/app/js/main.js&quot;, //唯一入口文件
        output: {
            path: __dirname + &quot;/build&quot;, //打包后的文件存放的地方
            filename: &quot;bundle.js&quot; //打包后输出文件的文件名
        },
        mode: &#39;development&#39;, // 设置mode
        devServer: {
            contentBase: __dirname + &#39;./build&#39;, //本地服务器所加载的页面所在的目录
            historyApiFallback: true, //不跳转
            inline: true //实时刷新
        },
        module: {
            rules: [{
                    test: /(\.jsx|\.js)$/,
                    use: {
                        loader: &quot;babel-loader&quot;
                    },
                    exclude: /node_modules/
                },
                {
                    test: /\.css$/,
                    use: [{
                        loader: &quot;style-loader&quot;
                    }, {
                        loader: &quot;css-loader&quot;,
                        options: {
                            modules: true, // 指定启用css modules
                            localIdentName: &#39;[name]__[local]--[hash:base64:5]&#39; // 指定css的类名格式
                        }
                    }]
                }
            ]
        },
        plugins: [
            new webpack.BannerPlugin(&#39;版权所有，翻版必究&#39;),
            new HtmlWebpackPlugin({
                template: __dirname + &quot;/app/index.tmpl.html&quot; //new 一个这个插件的实例，并传入相关的参数
            })
        ]
    }</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  引入插件名称，修改输出地址，在plugins里添加,运行npm start</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  发现文件夹里多了一个build的文件夹，打开文件，发现有一个index.html和build.js文件。用浏览器打开index.html，发现和原来public文件夹里的事一样的，这样打包更加的方便。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  如果你要实时更新你的代码，一定要配置好服务的内容devServer。</p>
<h3 id="优化插件"><a href="#优化插件" class="headerlink" title="优化插件"></a>优化插件</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; webpack提供了一些在发布阶段非常有用的优化插件，它们大多来自于webpack社区，可以通过npm安装，通过以下插件可以完成产品发布阶段所需的功能</p>
<ul>
<li>OccurenceOrderPlugin :为组件分配ID，通过这个插件webpack可以分析和优先考虑使用最多的模块，并为它们分配最小的ID</li>
<li>UglifyJsPlugin：压缩JS代码，这个因为高版本的需求，已经不用这个插件了（下面的配置中，我会配置）</li>
<li>ExtractTextPlugin：分离CSS和JS文件</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由于第一个和第二个是内置插件，只要引入就可以了，但是后面分离css和js，需要安装插件：</p>
<pre><code class="bash">    npm install --save-dev extract-text-webpack-plugin@next</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  为什么要加@next，因为extract-text-webpack-plugin目前版本不支持webpack4，下面是配置了组件分配Id，压缩js，分离了css和js：</p>
<pre><code class="javascript">    const webpack = require(&#39;webpack&#39;);
    const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
    const ExtractTextPlugin = require(&#39;extract-text-webpack-plugin&#39;);
    module.exports = {
        devtool: &#39;eval-source-map&#39;,
        entry: __dirname + &quot;/app/js/main.js&quot;, //唯一入口文件
        output: {
            path: __dirname + &quot;/build&quot;, //打包后的文件存放的地方
            filename: &quot;bundle.js&quot; //打包后输出文件的文件名
        },
        mode: &#39;development&#39;, // 设置mode
        devServer: {
            contentBase: __dirname + &#39;./build&#39;, //本地服务器所加载的页面所在的目录
            historyApiFallback: true, //不跳转
            inline: true //实时刷新
        },
        module: {
            rules: [{
                    test: /(\.jsx|\.js)$/,
                    use: {
                        loader: &quot;babel-loader&quot;
                    },
                    exclude: /node_modules/
                },
                {
                    test: /\.css$/,
                    use: ExtractTextPlugin.extract({
                        fallback: &quot;style-loader&quot;,
                        use: [{
                            loader: &quot;css-loader&quot;,
                            options: {
                                modules: true,
                                localIdentName: &#39;[name]__[local]--[hash:base64:5]&#39;
                            }
                        }]
                    })
                }
            ]
        },
        plugins: [
            new webpack.BannerPlugin(&#39;版权所有，翻版必究&#39;),
            new HtmlWebpackPlugin({
                template: __dirname + &quot;/app/index.tmpl.html&quot; //new 一个这个插件的实例，并传入相关的参数
            }),
            new webpack.optimize.OccurrenceOrderPlugin(),
            new ExtractTextPlugin(&quot;style.css&quot;)
        ],
        /* 压缩js代码 */
        optimization: {
            minimize: true
        }
    }
    //“__dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录。</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  运行npm start ，发现build文件夹里多出了style.css。</p>
<h3 id="引入图片"><a href="#引入图片" class="headerlink" title="引入图片"></a>引入图片</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  首先还是要装插件，终端：</p>
<pre><code class="bash">    npm install --save-dev url-loader</code></pre>
<p>Hello.css</p>
<pre><code class="css">    .rootchild{
        font-size: 20px;
        color:red;
        background-image: url(&#39;../img/hello.jpg&#39;);
        width: 197px;
        height: 197px;
    }</code></pre>
<p>Webpack.config.js</p>
<pre><code class="javascript">    {
        test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
        loader: &#39;url-loader?limit=8192&amp;name=img/[hash:8].[name].[ext]&#39;
    }</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  运行代码：npm start ，浏览器打开build文件夹下的index.html，如图:</p>
<p><img src="https://s2.ax1x.com/2019/03/27/AaK1OS.png" alt="图片展示"></p>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  写完这篇文章，想起当时搞这个基础配置，也花费了几天的时间，总是搞不好，版本的问题，配置问题，反正各种问题，也是各个博客去看自己错在什么地方，搞的人头都大了，总之当时功夫不负有心人，当时是成功了。这篇文章是比较基础的，对于新手入门还是很重要，只要按照流程，还是很容易的搭建出来，文章里有很多容易出错的点，我也列举出来了，对于点的介绍都很全面，如果看到这里，说明你已经基本入门了，可以很好地去了解其他关于webpack的知识点。</p>
<p>本文的代码在这里<a href="https://github.com/jsocean/webpackbasic" target="_blank" rel="noopener">webpackbasic</a></p>
</div><div class="p-copyright"><blockquote><div class="p-copyright-author"><span class="p-copyright-key">本文作者：</span><span class="p-copytight-value"><a href="mailto:litreily@163.com">JsOcean</a></span></div><div class="p-copyright-link"><span class="p-copyright-key">本文链接：</span><span class="p-copytight-value"><a href="/2019/03/27/webpack%E5%85%A5%E9%97%A8%E7%BA%A7%E7%AF%87%E7%AB%A0%EF%BC%8C%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/">http://jsocean.github.io/2019/03/27/webpack入门级篇章，看这篇就够了/</a></span></div><div class="p-copyright-note"><span class="p-copyright-key">版权声明：</span><span class="p-copytight-value">本博客所有文章除特殊声明外，均采用<a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/"> CC BY-NC 4.0 </a>许可协议。转载请注明出处 <a href="http://jsocean.github.io">JsOcean的博客</a>！</span></div></blockquote></div></article><div class="p-info box"><span class="p-tags"><i class="fa fa-tags"></i><a href="/tags/JavaScript/">JavaScript</a><a href="/tags/webpack/">webpack</a><a href="/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85/">自动化打包</a><a href="/tags/CMD-AMD-ES6/">CMD AMD ES6</a></span></div><aside id="toc"><div class="toc-title">目录</div><nav><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#序言"><span class="toc-number">1.</span> <span class="toc-text">序言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Webpack到底是什么鬼"><span class="toc-number">2.</span> <span class="toc-text">Webpack到底是什么鬼</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Webpack和Gulp、Grunt有什么区别，为什么使用Webpack"><span class="toc-number">3.</span> <span class="toc-text">Webpack和Gulp、Grunt有什么区别，为什么使用Webpack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Webpack具有的特性"><span class="toc-number">4.</span> <span class="toc-text">Webpack具有的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Webpack-安装及使用"><span class="toc-number">5.</span> <span class="toc-text">Webpack 安装及使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#强大的调试功能（生成Source-Maps）"><span class="toc-number">6.</span> <span class="toc-text">强大的调试功能（生成Source Maps）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Webpack搭建本地服务"><span class="toc-number">7.</span> <span class="toc-text">Webpack搭建本地服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Module"><span class="toc-number">8.</span> <span class="toc-text">Module</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Loaders"><span class="toc-number">9.</span> <span class="toc-text">Loaders</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Babel"><span class="toc-number">10.</span> <span class="toc-text">Babel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS模块"><span class="toc-number">11.</span> <span class="toc-text">CSS模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#插件学习（Plugins）"><span class="toc-number">12.</span> <span class="toc-text">插件学习（Plugins）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HtmlWebpackPlugin"><span class="toc-number">13.</span> <span class="toc-text">HtmlWebpackPlugin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优化插件"><span class="toc-number">14.</span> <span class="toc-text">优化插件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#引入图片"><span class="toc-number">15.</span> <span class="toc-text">引入图片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结束语"><span class="toc-number">16.</span> <span class="toc-text">结束语</span></a></li></ol></nav></aside></div><section class="p-ext"><div class="l-pager l-pager-dtl box"><a class="prev" href="/2019/04/15/JavaScript-%E5%87%A0%E7%A7%8D%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">&lt; JavaScript 几种简单的设计模式</a><a class="next" href="/2019/03/18/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%9D%E6%83%B3/">前后端分离的重要思想 &gt;</a></div><div id="valine-comment"><style type="text/css">.night .v[data-class=v] a { color: #0F9FB4 !important; }
.night .v[data-class=v] a:hover { color: #216C73 !important; }
.night .v[data-class=v] li { list-style: inherit; }
.night .v[data-class=v] .vwrap { border: 1px solid #223441; border-radius: 0; }
.night .v[data-class=v] .vwrap:hover { box-shadow: 0 0 6px 1px #223441; }
.night .v[data-class=v] .vbtn { border-radius: 0; background: none; }
.night .v[data-class=v] .vlist .vcard .vh { border-bottom-color: #293D4E; }
.night .v[data-class=v] .vwrap .vheader .vinput { border-bottom-color: #223441; }
.night .v[data-class=v] .vwrap .vheader .vinput:focus { border-bottom-color: #339EB4; }
.night .v[data-class=v] code, .night .v[data-class=v] pre,.night .v[data-class=v] .vlist .vcard .vhead .vsys { background: #203240 !important; }
.night .v[data-class=v] code, .night .v[data-class=v] pre { color: #F0F0F0; font-size: 95%; }
.v[data-class=v] .vcards .vcard .vh {border-bottom-color: #223441; }
.night .v[data-class=v] .vcards .vcard .vcontent.expand:before {background: linear-gradient(180deg,rgba(38,57,73,.4),rgba(38,57,73,.9));}
.night .v[data-class=v] .vcards .vcard .vcontent.expand:after {background: rgba(38,57,73,.9)}
</style><div id="vcomment"></div><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'',
  appKey:'',
  lang: 'zh-cn',
  placeholder:'请填写你的疑问......',
  avatar:'wavatar',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></section><footer><p>Copyright © 2016 - 2020 <a href="/." rel="nofollow">JsOcean</a> | <strong><a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a></strong><br><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span></span> <span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span></span> | Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a>Theme with<a rel="nofollow" target="_blank" href="https://github.com/litreily/snark-hexo"> snark.</a></p></footer></div></div></div><script type="text/javascript" src="/plugins/prettify/prettify.js"></script><script type="text/javascript" src="/js/search.js"></script><script type="text/javascript" src="/js/top.js"></script><script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
    search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"></body></html>